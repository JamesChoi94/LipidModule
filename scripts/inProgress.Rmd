---
title: "Untitled"
author: "James Choi"
date: "Last compiled:`r Sys.Date()`"
output: 
  html_document
editor_options:
  chunk_output_type: 
    console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.align='center', 
                      tidy.opts=list(width.cutoff=80), tidy=TRUE,
                      results='hold')
```

# Background


```{r libraries}
require('ggplot2')
require('dplyr')
require('WGCNA')
# require('Seurat')
require('DESeq2')
```

```{r directories}
if (!grepl('scripts', getwd())) {setwd('scripts')}
results_out <- '../results/WGCNA_allMac/'
dir.create(path = results_out)
```

```{r utils}
my_theme <- theme_bw() +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        strip.text = element_text(size = 12),
        plot.title = element_text(size = 14),
        plot.subtitle = element_text(size = 12))

```


# Data input, cleaning, preprocessing

## Import data

### Load CR's in vitro foam cell RNAseq

```{r load_CR_invitro}
invitro <- read.table(
  file = '../data/HIHG_results/jLee_counts_07012021.txt',
  sep = '\t',
  header = TRUE
)
rownames(invitro) <- invitro$Symbol
invitro <- invitro[sapply(invitro, is.numeric)]
```


### Load YZhu's Ribotag RNAseq

```{r load_YZhu_counts}
ribotag_files <- list.files(
  path = '../data/YZhu_Ribotag_featureCounts/',
  full.names = TRUE
)
ribotag_names <- strsplit(x = ribotag_files,  split = '/')
ribotag_names <- sapply(ribotag_names, `[`, 4)
ribotag_names <- strsplit(x = ribotag_names, split = ' ')
ribotag_names <- sapply(ribotag_names, `[`, 3)
ribotag_names <- gsub(
  pattern = '\\.tabular',
  replacement = '',
  x = ribotag_names
)
ribotag_names <- paste(
  c('D3_rep1','D3_rep2','D3_rep3','D7_rep1','D7_rep2','D7_rep3'),
  ribotag_names,
  sep = '_'
)
ribotag <- vector(mode = 'list', length = length(ribotag_files))
names(ribotag) <- ribotag_names
for (i in 1:length(ribotag_files)) {
  ribotag[[i]] <- read.table(
    file = ribotag_files[i],
    sep = '\t',
    header = TRUE
  )
  colnames(ribotag[[i]]) <- c('Gene_id', ribotag_names[i])
}

# Import converted gene IDs
ribotag_gene_info <- read.table(
  file = '../results/Zhu_RNAseq_Galaxy/featureCounts_gene_ID_convert/Cutadapt on SRR3945463.tabular',
  sep = '\t',
  header = TRUE
)

for (i in 1:length(ribotag)) {
  ribotag[[i]]$Ensembl <- plyr::mapvalues(
    x = ribotag[[i]]$Gene_id,
    from = ribotag_gene_info$ENTREZID,
    to = ribotag_gene_info$ENSEMBL,
    warn_missing = FALSE
  )
  ribotag[[i]]$Gene_name <- plyr::mapvalues(
    x = ribotag[[i]]$Gene_id,
    from = ribotag_gene_info$ENTREZID,
    to = ribotag_gene_info$SYMBOL,
    warn_missing = FALSE
  )
  ribotag[[i]] <- ribotag[[i]][c(1,3,4,2)]
}
ribotag <- lapply(
  X = ribotag,
  FUN = function(x) {
    x[!is.na(x$Ensembl) & !duplicated(x$Ensembl),]
  }
)
ribotag <- Reduce(f = left_join, x = ribotag)
rownames(ribotag) <- ribotag$Ensembl
ribotag <- ribotag[grepl('SRR[0-9]{1,}', colnames(ribotag))]
rm(ribotag_files, ribotag_names, ribotag_gene_info)
```


### Load SCI scRNAseq 

Since previous RNAseq datasets are quantified using Ensembl gene IDs, scSeq data
should also be in Ensembl format. For this, I first extract monocyte/macrophage
cell barcodes and generate count matrices from the raw, unfiltered .h5 files for
only these cell barcodes.

```{r load_scseq}
# Extract monocyte/macrophage barcodes
barcodes <- read.csv(file = '../../sci_scRNAseq/data/shinyAppData/obs_sci.csv')
colnames(barcodes)[1] <- 'barcodes'
barcodes <- barcodes[barcodes$L1_taxon == 'Myeloid',]
barcodes$myeloid <- plyr::mapvalues(
  x = barcodes$L3_taxon,
  from = c("Border-Associated Mac",
           "Chemotaxis-Inducing Mac",
           "Dendritic",
           "Dividing Microglia",
           "Dividing Myeloid",
           "Homeostatic Microglia",
           "Inflammatory Mac",
           "Inflammatory Microglia",
           "Interferon Myeloid",
           "Migrating Microglia",
           "Monocyte",
           "Neutrophil"),
  to = c('Macrophage',
         'Macrophage',
         'Dendritic',
         'Microglia',
         'Macrophage',
         'Microglia',
         'Macrophage',
         'Microglia',
         'IFN',
         'Microglia',
         'Macrophage',
         'Neutrophil')
)
barcodes <- barcodes[!is.na(barcodes$myeloid),]
barcodes <- barcodes[barcodes$myeloid %in% c('Microglia','Macrophage'),]
celltype <- barcodes$myeloid
barcodes <- barcodes$barcodes
barcodes <- strsplit(
  x = barcodes,
  split = '_'
)
barcodes <- data.frame(
  'barcodes' = paste(sapply(barcodes, `[`, 1), '-1', sep = ''),
  'sample' = sapply(barcodes, function(x) paste(x[2], x[3], sep = '_')),
  'celltype' = celltype
)

# Extract counts for barcodes by sample
scseq_files <- list.files(
  path = '../../sci_scRNAseq/data/raw_feature_bc_matrix/',
  full.names = TRUE
)
scseq_samples <- apply(
  X = expand.grid(unique(barcodes$celltype), unique(barcodes$sample)),
  MARGIN = 1,
  FUN = function(x) paste(x[2], x[1], sep = '.')
)
scseq_samples <- sort(scseq_samples)
scseq <- vector(mode = 'list', length = length(scseq_samples))
names(scseq) <- scseq_samples
tmp_kill <- 'tmp'
for (i in 1:length(scseq_samples)) {
  tmp_sample <- sapply(strsplit(scseq_samples[i], '\\.'), `[`, 1)
  tmp_celltype <- sapply(strsplit(scseq_samples[i], '\\.'), `[`, 2)
  tmp_barcodes <- barcodes$sample == tmp_sample &
    barcodes$celltype == tmp_celltype
  tmp_barcodes <- barcodes$barcodes[tmp_barcodes]
  if (tmp_sample != tmp_kill) {
    tmp_dat <- Seurat::Read10X_h5(
      filename = scseq_files[which(grepl(tmp_sample, scseq_files))],
      use.names = FALSE
    )
  }
  if (!all(tmp_barcodes %in% colnames(tmp_dat))) {
    next
  } else {
    message(scseq_samples[i], ': ', length(tmp_barcodes))
    tmp_ind <- which(colnames(tmp_dat) %in% tmp_barcodes)
    scseq[[i]] <- sparseMatrixStats::rowSums2(tmp_dat[,tmp_ind])
    names(scseq[[i]]) <- rownames(tmp_dat)
    tmp_kill <- tmp_sample
  }
}
# Remove uninjured macrophages. Include uninjured microglia for control data.
scseq <- scseq[!grepl('uninj.{1,}Macrophage$', names(scseq))]
# shared genes
tmp_genes <- Reduce(f = intersect, x = lapply(scseq, names))
if (any(duplicated(tmp_genes))) {
  stop('tmp_genes has duplicated genes')
} else if (!all(sapply(scseq, function(x) all(tmp_genes %in% names(x))))) {
  stop('stop')
} else {
  scseq <- lapply(scseq, function(x) x[tmp_genes])
}
scseq <- as.data.frame(scseq)
rm(barcodes, scseq_files, scseq_samples, tmp_kill, celltype)
rm(list = ls()[grepl('tmp', ls())])
```


## Assemble count matrix

### Identify shared genes across assays

```{r find_common_genes}
# take subset of shared genes
counts <- list(invitro, ribotag, scseq)
shared_ensembl <- Reduce(f = intersect, x = lapply(counts, rownames))
if (!all(sapply(counts, function(x) all(shared_ensembl %in% rownames(x))))) {
  stop('Not all shared_ensembl genes are in all datasets')
} else if (any(duplicated(shared_ensembl))) {
  stop('non-unique Ensembl gene IDs present')
} else {
  counts <- lapply(
    X = counts,
    FUN = function(x) x[shared_ensembl,]
  )
}
counts <- data.frame(counts)
counts <- as.matrix(counts)

# use CR's invitro dataset to convert gene names (can also use biomaRt)
gene_info <-  read.table(
  file = '../data/HIHG_results/jLee_counts_07012021.txt',
  sep = '\t',
  header = TRUE
)
gene_info <- gene_info[sapply(gene_info, function(x) !is.numeric(x))]
gene_info$Gene_name <- gsub(
  pattern = '\\"',
  replacement = '',
  x = gene_info$Gene_name
)
# convert ensembl to common gene name and remove duplicated gene names
counts_genes <- plyr::mapvalues(
  x = rownames(counts),
  from = gene_info$Symbol,
  to = gene_info$Gene_name,
  warn_missing = FALSE
)
remove_duplicates <- which(duplicated(counts_genes))
counts <- counts[-remove_duplicates,]
rownames(counts) <- counts_genes[-remove_duplicates]
dim(counts)
```


### Set sample names

```{r}
rename_samples <- c(
  "Rapa1.FoamCellTorinRapa" = 'invitro_Rapa_sample1',
  "Rapa2.FoamCellTorinRapa" = 'invitro_Rapa_sample2',
  "Rapa3.FoamCellTorinRapa" = 'invitro_Rapa_sample3',
  "Torin1.FoamCellTorinRapa" = 'invitro_Torin_sample1',
  "Torin2.FoamCellTorinRapa" = 'invitro_Torin_sample2',
  "Torin3.FoamCellTorinRapa" = 'invitro_Torin_sample3',
  "Veh1.FoamCellTorinRapa" = 'invitro_Veh_sample1',
  "Veh2.FoamCellTorinRapa" = 'invitro_Veh_sample2',
  "Veh3.FoamCellTorinRapa" = 'invitro_Veh_sample3',
  "D3_rep1_SRR3945463" = 'Ribotag_3dpi_sample1',
  "D3_rep2_SRR3945464" = 'Ribotag_3dpi_sample2',
  "D3_rep3_SRR3945465" = 'Ribotag_3dpi_sample3',
  "D7_rep1_SRR3945466" = 'Ribotag_7dpi_sample1',
  "D7_rep2_SRR3945467" = 'Ribotag_7dpi_sample2',
  "D7_rep3_SRR3945468" = 'Ribotag_7dpi_sample3',
  'X1dpi_sample1.Macrophage' = 'scseqMacrophage_1dpi_sample1',
  'X1dpi_sample1.Microglia' = 'scseqMicroglia_1dpi_sample1',
  'X1dpi_sample2.Macrophage' = 'scseqMacrophage_1dpi_sample2',
  'X1dpi_sample2.Microglia' = 'scseqMicroglia_1dpi_sample2',
  'X1dpi_sample3.Macrophage' = 'scseqMacrophage_1dpi_sample3',
  'X1dpi_sample3.Microglia' = 'scseqMicroglia_1dpi_sample3',
  'X3dpi_sample1.Macrophage' = 'scseqMacrophage_3dpi_sample1',
  'X3dpi_sample1.Microglia' = 'scseqMicroglia_3dpi_sample1',
  'X3dpi_sample2.Macrophage' = 'scseqMacrophage_3dpi_sample2',
  'X3dpi_sample2.Microglia' = 'scseqMicroglia_3dpi_sample2',
  'X7dpi_sample1.Macrophage' = 'scseqMacrophage_7dpi_sample1',
  'X7dpi_sample1.Microglia' = 'scseqMicroglia_7dpi_sample1',
  'X7dpi_sample2.Macrophage' = 'scseqMacrophage_7dpi_sample2',
  'X7dpi_sample2.Microglia' = 'scseqMicroglia_7dpi_sample2',
  'uninj_sample1.Microglia' = 'scseqMicroglia_uninj_sample1',
  'uninj_sample2.Microglia' = 'scseqMicroglia_uninj_sample2',
  'uninj_sample3.Microglia' = 'scseqMicroglia_uninj_sample3')
colnames(counts) <- as.character(plyr::mapvalues(
  x = colnames(counts),
  from = names(rename_samples),
  to = rename_samples
))
```


### Save

```{r save}
write.table(x = counts, file = '../data/counts.tsv', quote = FALSE,
            col.names = NA, row.names = TRUE, sep = '\t')
```


```{r reload}
counts <- read.table(file = '../data/counts.tsv', sep = '\t', row.names = 1,
                     header = TRUE)
counts <- as.matrix(counts)
```



### Inspect library size

```{r library_size, fig.height=4, fig.width=4}
p1 <- data.frame(library_size = apply(counts, 2, sum)/1e6) %>% 
  mutate(sample = rownames(.)) %>% 
  mutate(study = sapply(strsplit(sample, '_'), `[`, 1)) %>% 
  mutate(group = sapply(strsplit(sample, '_'),
                        function(x) paste(x[1], x[2], sep = '_'))) %>% 
  mutate(sample = sapply(strsplit(sample, '_'), `[`, 3)) %>% 
  ggplot(mapping = aes(x = group, y = library_size)) +
  geom_boxplot(mapping = aes(fill = study), alpha = 0.5) +
  geom_point(mapping = aes(fill = study), color = 'black', pch = 21, size = 2) +
  scale_y_continuous(limits = c(0, NA),
                     breaks = seq(0, 100, 10)) +
  scale_fill_manual(values = c('invitro' = 'indianred',
                               'Ribotag' = 'goldenrod',
                               'scseqMacrophage' = 'dodgerblue',
                               'scseqMicroglia' = 'darkorchid')) +
  my_theme +
  labs(title = 'Library size') +
  ylab(label = 'Sum of counts (in millions)') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank(),
        plot.margin = margin(l = 10, t = 2.5, unit = 'mm')) +
  guides(fill = guide_legend(title = 'Study'))
ggsave(filename = paste0(results_out, 'library_size.tiff'),
       plot = p1, height = 4, width = 6, device = 'tiff')
p1
```


## Remove bad genes

```{r}
by_study <- sapply(strsplit(x = colnames(counts), split = '_'), `[` ,1)
split_counts <- split(as.data.frame(t(counts)), f = by_study)
split_counts <- lapply(X = split_counts, FUN = t)
var_genes <- lapply(
  X = split_counts,
  FUN = Seurat::FindVariableFeatures
)
var_genes <- lapply(
  X = var_genes,
  FUN = function(x) {
    return(rownames(x)[order(x$vst.variance, decreasing = TRUE)[1:5000]])
  }
)
var_genes <- Reduce(f = union, x = var_genes)
split_counts <- lapply(X = split_counts, function(x) x[var_genes,])
split_counts <- Reduce(f = cbind, x = split_counts)
counts <- split_counts
```

```{r}
# gene summaries
gene_sum <- rowSums(x = counts)
gene_mean <- rowMeans(x = counts)
gene_var <- sparseMatrixStats::rowVars(x = counts)
# WGCNA filtering
gene_pass <- goodGenes(datExpr = data.frame(t(counts)))
table(gene_pass)
rownames(counts)[!gene_pass]
counts_unfiltered <- counts
samples_pass <- goodSamples(datExpr = data.frame(t(counts)))
table(samples_pass)
counts <- counts[gene_pass, samples_pass]
counts <- as.data.frame(t(counts))
dim(counts)
```

```{r}
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(
  data = counts, 
  powerVector = powers, 
  verbose = 5,
  # corFnc = cor, 
  # corOptions = list(use = 'p', method = 'spearman')
)

par(mfrow = c(1,2))
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", 
     ylab = "Scale Free Topology Model Fit, signed R^2",
     type = "n", 
     main = paste("Scale independence"))
text(x = sft$fitIndices[,1],
     y = -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     labels = powers,
     cex = 1,
     col = "red");
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels = powers, 
     cex = 1, 
     col = "red")
```

```{r}
softPower = 10
adjacency = adjacency(datExpr = counts, power = softPower)
TOM = TOMsimilarity(adjacency)
dissTOM = 1 - TOM
geneTree = hclust(as.dist(dissTOM), method = "average")
plot(geneTree, xlab="", sub="", 
     main = "Gene clustering on TOM-based dissimilarity", labels = FALSE, 
     hang = 0.04)
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize)
table(dynamicMods)
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
MEList = moduleEigengenes(counts, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average")
# Plot the result
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;

```





# Scratch ------------------------------

Weighted Gene Correlation Network Analysis (WGCNA) is a 

We want to remove the dependence of variance on the mean. This will allow 

```{r}
scseq_norm <- t(t(scseq)/colSums(scseq)*1e5)
scseq_norm <- preprocessCore::normalize.quantiles(x = scseq_norm)
rownames(scseq_norm) <- rownames(scseq)
colnames(scseq_norm) <- colnames(scseq)
scseq_pca <- prcomp(x = t(scseq))
pc <- c(1,2)
plot(scseq_pca$x[,pc[1]], scseq_pca$x[,pc[2]],
     pch = 16, cex = 2, xlab = paste('PC', pc[1]), ylab = paste('PC', pc[2]))
text(x = scseq_pca$x[,pc[1]], y = scseq_pca$x[,pc[2]], 
     label = colnames(scseq_norm), cex = 1)
scseq_pca$x %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = 'group') %>% 
  ggplot(mapping = aes(x = PC1, y = PC2)) +
  geom_point() +
  ggrepel::geom_text_repel(mapping = aes(label = group))
```


```{r}
by_study <- sapply(strsplit(x = colnames(counts), split = '_'), `[` ,1)
test <- split(x = data.frame(t(counts)), f = by_study)
test <- preprocessCore::normalize.quantiles(x = counts)
dimnames(test) <- dimnames(counts)
quantNorm = function(x) qnorm(
 rank(x, ties.method = "average") / (length(x) + 1)
)
test <- apply(test, 1, quantNorm)
test <- t(test)
test <- t(scale(t(test)))
rownames(test) <- rownames(counts)
test_pca <- prcomp(x = t(test))
study_cols <- c('invitro' = 'indianred',
                'Ribotag' = 'goldenrod',
                'scseqMacrophage' = 'dodgerblue',
                'scseqMicroglia' = 'darkorchid')
by_study <- sapply(strsplit(x = colnames(counts), split = '_'), `[` ,1)
pc <- c(1,2)
plot(test_pca$x[,pc[1]], test_pca$x[,pc[2]], col = study_cols[by_study],
     pch = 16, cex = 2, xlab = paste('PC', pc[1]), ylab = paste('PC', pc[2]))
text(x = test_pca$x[,pc[1]], y = test_pca$x[,pc[2]], label = colnames(counts),
     cex = 0.5)

by_celltype <- ifelse(grepl('Microglia', colnames(counts)),
                      'Microglia',
                      'Macrophage')
by_tech <- ifelse(grepl('scseq', colnames(counts)),
                  'scseq_v2',
                  'bulk')
by_tech[by_tech == 'scseq_v2' & grepl('sample3', colnames(counts))] <- 'scseq_v3'


```



```{r}
by_study <- sapply(strsplit(x = colnames(counts), split = '_'), `[` ,1)

tmp <- counts[,grepl('scseq', colnames(counts))]
tmp_libsize <- colSums(tmp)
# tmp <- t(t(tmp)/tmp_libsize * 1e6)
tmp <- log2(tmp + 1)
tmp_means <- apply(tmp, 1, mean)
tmp_vars <- apply(tmp, 1, var)
plot(tmp_means, tmp_vars)

tmp <- counts[,grepl('scseq', colnames(counts))]
tmp_libsize <- colSums(tmp)
# tmp <- t(t(tmp)/tmp_libsize * 1e6)
# tmp <- log10(tmp + 1)
tmp_means <- apply(tmp, 1, mean)
tmp_vars <- apply(tmp, 1, var)
plot(log10(tmp_means), log10(tmp_vars))
abline(0, 1)


tmp <- counts[,grepl('scseq', colnames(counts))]
tmp1 <- DESeq2::varianceStabilizingTransformation(tmp, blind = FALSE)
tmp_means <- apply(tmp1, 1, mean)
tmp_vars <- apply(tmp1, 1, var)
plot(tmp_means, tmp_vars)
```


### Remove low quality genes

```{r}
# gene summaries
gene_sum <- rowSums(x = counts)
gene_mean <- rowMeans(x = counts)
gene_var <- sparseMatrixStats::rowVars(x = counts)
# WGCNA filtering
gene_pass <- goodGenes(datExpr = data.frame(t(counts)))
rownames(counts)[!gene_pass]
counts_unfiltered <- counts
counts <- counts[gene_pass,]
counts <- t(counts)
samples_pass <- goodSamples(datExpr = data.frame(t(counts)))


tmp <- cor(counts, method = 'pearson')
sampleTree <- hclust(d = as.dist(tmp), method = 'average')
plot(sampleTree)
ComplexHeatmap::Heatmap(tmp)
sampleTree = hclust(dist(t(counts)), method = "average")
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)

tmp <- DESeq2::varianceStabilizingTransformation(
  object = counts,
  blind = FALSE
)
table(gene_sum < 20)
hist(log10(gene_sum))
remove_genes <- gene_mean < 
table(remove_genes)
counts[which.max(gene_mean),]
```

```{r}
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(counts, powerVector = powers, verbose = 5)

par(mfrow = c(1,2))
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", 
     ylab = "Scale Free Topology Model Fit, signed R^2",
     type = "n", 
     main = paste("Scale independence"))
text(x = sft$fitIndices[,1],
     y = -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     labels = powers,
     cex = 1,
     col = "red");
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels = powers, 
     cex = 1, 
     col = "red")

```

